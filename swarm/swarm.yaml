version: "1"

tasks:
  planner:
    prompt-string: |
      # Find an improvement or issue
      Look through the swarm/PLAN.md file and the code base in general and find something to improve - like if a command is missing, or if a feature is not fully completed up to where it could be. 

      If everything is looking ok, invent a new feature that would be highly useful to an agent working on the project.

      # Write a feature file

      Then plan out the feature and write it to ./swarm/todo/{feature-name}.pending.md

      # Exit condition

      If you fail to find an improvement, or if you've successfully written a single feature - exit immediately.

  coder:
    prompt-string: |
      # Find unfinished tasks

      Use your agent id to find tasks that you left unfinished by looking for files named:
      ./swarm/todo/\*.{SWARM_TASK_ID}.processing.md

      If you found a task to continue, skip the "Find a task to complete" section and jump straight to "Execute the task".

      # Find a task to complete

      Look under the ./swarm/todo/ folder for a file suffixed with ".pending.md" - and claim it as a task by renaming it to ".{SWARM_TASK_ID}.processing.md".
      Make sure the file you choose doesn't have any dependencies that are not completed.
      Make sure your work won't conflict with other work that is already in progress.
      If no tasks are found - skip the "Execute the task" step and go to the "If nothing to do" step.

      # Implement the task

      Then read the file and execute the task to completion, adding tests and testing when you think you need to.
      When done, rename the file to ".completed.md" and add a note about what you did.
      If you can\'t complete the task, rename the file to ".pending.md" and add a note about what went wrong to the file.

      # If nothing to do

      If there are no pending tasks found, your job is to test the feature and report any issues.
      Then write those issues as new pending tasks in the swarm/todo/{feature-name}/ folder.
      When you have done that exit immediately!

    depends_on: [planner]

  refactor:
    prompt-string: |
      # Review unstaged git changes for refactoring opportunities

      Run `git diff` to see all unstaged changes in the repository.

      # Analyze the changes

      Look through the diff output and identify refactoring opportunities such as:
      - Code duplication that could be extracted into shared functions/components
      - Overly complex functions that should be broken down
      - Poor naming that could be clarified
      - Missing type safety or loose typing
      - Dead code or unused imports introduced by the changes
      - Inconsistent patterns compared to the rest of the codebase

      # Apply refactors

      If you find refactoring opportunities, apply them directly to the code.
      Keep changes minimal and focused — don't refactor code outside of what was touched by the unstaged changes.
      Make sure the code still compiles and any relevant tests still pass after your refactors.

      # If nothing to refactor

      If the unstaged changes look clean, exit immediately.

    depends_on: [coder]

  checker:
    prompt-string: |
      # Review unstaged git changes for bugs

      Run `git diff` to see all unstaged changes in the repository.

      # Analyze the changes for bugs

      Carefully review the diff output and look for bugs such as:
      - Off-by-one errors or incorrect boundary conditions
      - Null/undefined access without proper guards
      - Race conditions or missing awaits on async calls
      - Incorrect logic (wrong operator, inverted condition, swapped arguments)
      - Unhandled error cases or missing try/catch blocks
      - Security issues (unsanitized input, exposed secrets, injection vectors)
      - State management bugs (stale closures, missing dependency arrays, mutation of shared state)
      - Type mismatches or unsafe casts that could cause runtime errors

      # Fix bugs

      If you find bugs, fix them directly in the code.
      Keep fixes minimal and targeted — only fix actual bugs, don't refactor or add features.
      Make sure the code still compiles and any relevant tests still pass after your fixes.

      # If no bugs found

      If the unstaged changes look correct, exit immediately.

    depends_on: [refactor]

  tester:
    prompt-string: |
      # Run final tests

      Run the full test suite to make sure everything passes:
      - Run `npm test` (or the appropriate test command for this project)
      - Run `npm run build` to verify the project compiles cleanly
      - If there are linting scripts configured, run those too

      # Fix any failures

      If any tests fail or the build breaks:
      - Read the error output carefully
      - Fix the issues directly in the code
      - Re-run the failing tests to confirm the fix
      - Repeat until everything passes

      # Push to git

      Once all tests pass and the build is clean:
      - Run `git add -A` to stage all changes
      - Run `git diff --cached --stat` to review what will be committed
      - Write a concise, descriptive commit message summarizing the changes made in this iteration
      - Run `git commit` with that message
      - Run `git push` to push the commit to the remote

      # If nothing to push

      If there are no unstaged or staged changes (nothing was modified in this iteration), exit immediately.

    depends_on: [checker]

pipelines:
  development:
    iterations: 30
    tasks: [planner, coder, refactor, checker, tester]
